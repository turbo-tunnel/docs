{"./":{"url":"./","title":"使用说明","keywords":"","body":"TurboTunnel使用文档 环境要求 操作系统： Windows、Linux、MacOS Python: >=3.5 安装方法 $ pip3 install turbo-tunnel 使用turbo-tunnel命令测试安装是否成功。如果提示没有找到程序，可以使用python3 -m turbo_tunnel来执行命令。 基本功能 在turbo-tunnel中每种类型的隧道服务都会定义一个URL，例如：http://1.1.1.1:8080/、ssh://2.2.2.2:2222/等。不同服务通过URL中的协议区分。用户也可以定义自己的隧道协议。 基本上每种类型的隧道都会实现一个TunnelServer和Tunnel类。在命令行中，使用-l/--listen参数可指定要监听服务的相关信息；而使用-t/--tunnel参数可以指定后续要穿越的隧道。 监听服务时，如果指定了IP地址，表示会使用该地址进行监听；如果不指定，例如http://:8080/，则表示监听在全局地址：0.0.0.0。 主要功能 使用说明 端口转发 HTTP代理服务 HTTPS代理隧道 SSH隧道 WebSocket隧道 Socks代理隧道 嵌套隧道 透明代理 配置文件 扩展插件 ttun.top 版权所有 all right reserved，powered by Gitbook该文件修订时间： 2021-01-30 01:07:12 "},"port_forward.html":{"url":"port_forward.html","title":"端口转发","keywords":"","body":"端口转发 功能 用于将远程端口映射到本地，支持通过多层代理来映射表目标服务。 直接映射端口 $ turbo-tunnel -l tcp://127.0.0.1:3344 -t tcp://www.qq.com:80 这样可以将www.qq.com:80映射到本地的127.0.0.1:3344。因此，可以使用curl http://127.0.0.1:3344/ -H \"Host: www.qq.com\"来访问QQ首页。 通过隧道映射端口 $ turbo-tunnel -l tcp://127.0.0.1:3344 -t http://web-proxy.com:8080 -t tcp://www.qq.com:80 这里是通过https代理隧道来映射端口，一般用于需要通过代理服务器访问外网的场景。 通过多层嵌套代理映射端口 $ turbo-tunnel -l tcp://127.0.0.1:3344 -t http://web-proxy.com:8080 -t ssh://1.1.1.1:2222/ -t tcp://192.168.1.1:80 这样可以通过https和ssh两层嵌套代理来映射端口。这种情况一般是ssh服务器上部署了一个跳板机服务，需要通过该跳板机才能访问目标网络，例如这里的：192.168.1.1；而访问ssh服务又需要通过https代理。 映射SSL端口 $ turbo-tunnel -l tcp://127.0.0.1:3344 -t ssl://www.qq.com:443 这样可以在本地直接访问明文服务，隧道会自动进行SSL加密。例如，这里可以使用curl http://127.0.0.1:3344/ -H \"Host: www.qq.com\"访问www.qq.com:443的https服务。 对于域名解析非预期的场景，可以使用ssl://1.1.1.1:443/?server_hostname=www.qq.com来指定证书域名。对于自签名证书，可以使用ssl://1.1.1.1:443/?verify_ssl=false来禁用证书校验。 端口映射时，最后一个tunnel一定是tcp://或ssl://类型的。 ttun.top 版权所有 all right reserved，powered by Gitbook该文件修订时间： 2021-01-30 00:02:28 "},"http.html":{"url":"http.html","title":"HTTP代理服务","keywords":"","body":"HTTP代理服务 功能 由于HTTP代理协议无法作为隧道协议，因此这里仅仅是作为HTTP代理服务端，以便用户可以更加便捷地访问HTTP服务。 创建HTTP(S)代理服务 $ turbo-tunnel -l http://test:123@0.0.0.0:8080/ 该命令会创建一个既支持HTTP代理，又支持HTTPS代理的服务端。为了充分复用已有隧道的能力，代理服务在接收到HTTP请求后会尽量使用已有隧道发送请求，以降低不必要的连接成本。 使用HTTP代理 $ curl http://www.xxx.com/ -x http://test:123@0.0.0.0:8080/ ttun.top 版权所有 all right reserved，powered by Gitbook该文件修订时间： 2021-01-30 00:51:28 "},"https.html":{"url":"https.html","title":"HTTPS代理隧道","keywords":"","body":"HTTPS代理隧道 功能 提供HTTPS代理隧道服务端和客户端的能力。 创建HTTPS代理服务 $ turbo-tunnel -l http://test:123@0.0.0.0:8080/ 该命令创建了一个监听在本地8080端口的HTTPS代理服务，用户名和密码为：test和123，所有代理请求会使用当前机器网络进行转发。 指定HTTPS代理隧道 $ turbo-tunnel -l http://:8080/ -t http://name:password@web-proxy.com:8080 该命令会创建一个HTTPS代理服务器，并通过另一个HTTPS代理服务web-proxy.com:8080转发所有流量，该代理服务器使用name和password进行鉴权。 ttun.top 版权所有 all right reserved，powered by Gitbook该文件修订时间： 2021-01-30 00:02:28 "},"ssh.html":{"url":"ssh.html","title":"SSH隧道","keywords":"","body":"SSH隧道 功能 提供了简易SSH服务端以及SSH转发隧道的能力。 SSH服务端 $ turbo-tunnel -l ssh://name:password@:2222/ 该命令创建了一个用户名为name，密码为password，监听端口为2222的SSH服务端。 该SSH服务端支持Linux、Windows、MacOS等系统，支持执行SHELL命令，支持PTY，支持端口转发，支持scp。 $ turbo-tunnel -l ssh://name:password@:2222/?private_key=/path/to/private-key 使用private_key参数可以指定服务端使用的私钥文件路径，不指定则会在当前路径下寻找名为skey的私钥文件，如果不存在则会新建一个新的秘钥文件。 $ turbo-tunnel -l ssh://:2222/?public_key=/path/to/public-key 使用public_key参数可以指定鉴权使用的公钥文件，允许用户使用公私钥方式登录SSH服务端。 SSH隧道客户端 $ turbo-tunnel -l http://:8080/ -t ssh://1.1.1.1:2222/?private_key=/path/to/private-key 该命令会创建一个HTTPS代理服务端，并通过SSH服务端1.1.1.1:2222转发所有流量。这里的private_key表示使用公私钥方式进行鉴权时的私钥路径。 这里的SSH服务端需要开启端口转发能力，目前暂不支持未开启端口转发的SSH服务端。 ttun.top 版权所有 all right reserved，powered by Gitbook该文件修订时间： 2021-01-30 00:02:28 "},"websocket.html":{"url":"websocket.html","title":"WebSocket隧道","keywords":"","body":"WebSocket隧道 功能 提供WebSocket隧道服务端和客户端能力。 WebSocket隧道服务端 $ turbo-tunnel -l ws://username:password@127.0.0.1/{addr}/{port} 此命令可以创建WebSocket隧道服务端，其中{addr}和{port}在这里是变量占位符，用于指示目标地址和目标端口参数。 这是因为WebSocket协议本身并不是一种标准的隧道协议，因此需要使用特定的字段来指定目标地址信息。 运行过程中，当需要访问1.1.1.1:8888服务时，客户端会动态生成请求路径：/1.1.1.1/8888。 这里可以根据使用者的需要改成不同的格式，例如：/proxy-{addr}-{port}或/proxy?addr={addr}&port={port}。但是，这里设置的格式需要与客户端指定的url格式保持一致。 WebSocket隧道客户端 $ turbo-tunnel -l http://:8080/ -t ws://username:password@127.0.0.1/{addr}/{port} 该命令会创建一个HTTPS代理服务端，并通过WebSocket隧道ws://username:password@127.0.0.1/{addr}/{port}转发所有流量。 使用WSS协议 turbo-tunnel本身没有提供SSL服务端支持，需要使用者在外面套一层nginx之类的Web容器来支持SSL，这也是推荐的使用方法。 ttun.top 版权所有 all right reserved，powered by Gitbook该文件修订时间： 2021-01-30 00:02:28 "},"socks.html":{"url":"socks.html","title":"Socks代理隧道","keywords":"","body":"Socks代理隧道 功能 提供Socks4代理隧道服务端和客户端能力。 Socks5代理隧道正在支持中…… Socks4代理隧道服务端 $ turbo-tunnel -l socks4://userid@127.0.0.1:1080 该命令可以创建一个Socks4代理隧道服务端，userid参数用于鉴权，不指定则无需鉴权。 socks4://也可以写成socks://，表示默认使用socks4协议。 Socks4代理隧道客户端 $ turbo-tunnel -l http://:8080/ -t socks4://userid@127.0.0.1:1080 该命令会创建一个HTTPS代理服务端，并通过Socks4代理隧道转发所有流量。 ttun.top 版权所有 all right reserved，powered by Gitbook该文件修订时间： 2021-01-30 00:02:28 "},"nested_tunnel.html":{"url":"nested_tunnel.html","title":"嵌套隧道","keywords":"","body":"嵌套隧道 什么是嵌套隧道 嵌套隧道是指某些情况下，需要依次穿越多个同种类型或不同类型的隧道，以访问目标服务的情况。例如：有些内网环境下需要先通过一个HTTPS代理访问外网，然后再通过一个SSH堡垒机访问目标服务。 使用turbo-tunnel建立嵌套隧道 在通常使用场景下，对于这种情况，需要先使用proxifier之类的软件让SSH客户端通过HTTPS代理访问SSH服务器，进去后再使用ssh命令进入目标机器，使用相对较为繁琐。 通过在turbo-tunnel命令行中使用-t/--tunnel参数配置多个隧道，形成嵌套隧道。隧道的嵌套顺序由-t/--tunnel参数的顺序决定。 $ turbo-tunnel -l http://127.0.0.1:8888/ -t http://web-proxy.internal.com:8080/ -t ssh://username:password@1.1.1.1/ 该命令可以在本地创建一个HTTPS代理服务，通过该服务可以直接建立与堡垒机内部机器的网络连接。 对于嵌套层数越多的场景，使用turbo-tunnel的优势就越明显，因为所有的访问都会收敛到本地的HTTPS服务中。 turbo-tunnel支持任意层数的隧道嵌套，包括插件中提供的隧道。 ttun.top 版权所有 all right reserved，powered by Gitbook该文件修订时间： 2021-01-30 00:02:28 "},"transparent_proxy.html":{"url":"transparent_proxy.html","title":"透明代理","keywords":"","body":"透明代理 什么是透明代理 透明代理是指不需要应用主动配置代理就可以自动通过代理访问服务的代理技术，这种情况下代理对应用完全透明，应用不会感知到代理的存在。相比于普通代理方式，这种方式不需要应用主动支持代理即可使用，因此应用范围更加广泛。 常见的透明代理方案有： 修改路由表 修改iptables Hook socket函数 前两种方案会影响所有应用，因此也称作全局代理。第三种方案只会影响指定的应用，影响范围相对可控。Windows和Macos上常用的透明代理工具是Proxifier，Linux上常用的工具是proxychains。 透明代理很好地解决了许多应用不支持配置代理，导致在部分网络环境下无法正常使用的问题。 Proxifier除了支持HTTPS、SOCKS等代理协议，还支持配置多个代理服务器和路由规则，这在复杂网络环境下是非常有用的。turbo-tunnel也提供了类似的能力，并且支持更多的隧道类型。 proxychains则相对弱了一些，不支持配置路由规则，但是通过与turbo-tunnel的结合，可以做到在Linux上也能方便地进行动态路由管理。 ttun.top 版权所有 all right reserved，powered by Gitbook该文件修订时间： 2021-01-30 01:05:57 "},"config.html":{"url":"config.html","title":"配置文件","keywords":"","body":"使用配置文件 配置文件可以做什么 配置文件可以简化命令行参数，允许配置多个隧道和路由规则，从而根据不同请求匹配不同的路由。 编写配置文件 配置文件使用yaml语法，基本格式如下： version: 1.0 # yaml文件版本，暂时没有用到，留作升级使用 listen: http://127.0.0.1:6666 # 配置监听地址 plugins: - relay_tunnel # 指定用到的插件 tunnels: - id: direct url: tcp:// default: true # 默认使用直连策略 - id: block url: block:// # 禁止访问策略 - id: web url: http://web-proxy.com:8080 - id: private url: wss://test:mypassword@ws-proxy.com/proxy/{addr}/{port} dependency: web # 配置隧道依赖关系 rules: - id: local priority: 100 # 优先级，1-100，策略冲突时会选择优先级最高的策略 addr: 127.0.0.1 tunnel: direct - id: internal priority: 99 addr: \"192.168.*\" port: 1-65535 tunnel: direct - id: public priority: 90 addr: \"*\" port: 80;443;8080 tunnel: web # 访问外网使用`web`隧道 - id: private priority: 95 addr: \"*.private.com\" port: 1-65535 tunnel: private - id: test priority: 90 addr: \"*.baidu.com\" port: 80;443 tunnel: block # 不允许访问 $ turbo-tunnel -c tunnel.yml 使用-c/--config参数可以指定配置文件。 ttun.top 版权所有 all right reserved，powered by Gitbook该文件修订时间： 2021-01-30 00:02:28 "},"plugin.html":{"url":"plugin.html","title":"扩展插件","keywords":"","body":"插件支持 插件是什么 turbo-tunnel插件主要用于对turbo-tunnel能力的扩展，例如：支持更多的第三方/自定义隧道协议；提供流量分析、流量劫持等功能。 如何使用插件 turbo-tunnel插件本质上就是一个python库，在turbo-tunnel命令行中可以使用-p/--plugin参数加载指定的插件包名。 例如，对于内置插件terminal，可以使用以下命令加载： $ turbo-tunnel -l http://127.0.0.1:8888/ -p terminal 如何实现插件 由于turbo-tunnel是基于asyncio、tornado等库开发，因此，插件也必须使用asyncio，以保证整体的兼容。 支持第三方隧道/自定义隧道 1、 实现隧道客户端（继承自turbo_tunnel.tunnel.Tunnel或其子类），并且将其注册到turbo-tunnel中。下面以SSH隧道为例： turbo_tunnel.registry.tunnel_registry.register(\"ssh\", SSHTunnel) 在代码顶层执行以上代码，即可注册SSH隧道。这里的ssh表示使用的协议，不同的隧道类型应当使用不同的协议。 这里需要在代码顶层执行以上代码，是为了在加载插件时自动注册，否则会导致无法使用指定的隧道。 2、 实现隧道服务端 隧道服务端不是必需的，因为有些隧道服务已经有很好的实现了，例如SSH Server。对于这种情况，可以不提供隧道服务端。 对于自定义隧道，就需要自己实现隧道服务端了，它一般是继承自turbo_tunnel.server.TunnelServer，并且实现了start方法，用于开启服务。在接收到请求后，会根据指定的路由或策略配置动态选择路由，并进行请求的转发。 提供流量分析、处理能力 插件定义了如下一些回调接口，在特定事件发生时通知到插件： class Plugin(object): def on_load(self): pass def on_unload(self): pass def on_tunnel_selected(self, address, rule, tunnel): pass def on_new_connection(self, connection): pass def on_tunnel_address_updated(self, connection, tunnel_address): pass def on_data_recevied(self, connection, buffer): pass def on_data_sent(self, connection, buffer): pass def on_connection_closed(self, connection): pass 插件可以基于这些接口执行一些操作，例如抓包、分析流量等工作；目前尚不支持修改数据包，等后面支持了，就可以执行流量修改等操作了。 ttun.top 版权所有 all right reserved，powered by Gitbook该文件修订时间： 2021-01-30 00:02:28 "}}